<the original article expired, here is what I have left from it>
Subject: gcc 2.7.0 bug w/ unsigned compare on 486
>This is gcc 2.7.0, i486-linux (ELF) (H.J. Lu's binary distribution for
>Linux).
>
>Put the following in a file "bug.c" and compile it with
>  gcc -O -o bug bug.c
>--------------------------------------------------
>#include <stdio.h>
>
>void bug (unsigned int x, unsigned int y);
>
>int main(int argc, char **argv) {
>  bug(0x7ffffff3, 0x80000001);
>  return 0;
>}
>
>void bug (unsigned int x, unsigned int y) {
>  if (x == 0) {
>    printf("Never get here.\n");
>  }
>  if (y == 0) {
>    printf("Never get here.\n");
>  }
>  x -= y;
>  if (x < (unsigned int)0x80000000) {
>    printf("GCC says 0x%x is less than 0x8000000!\n", x);
>  } else {
>    printf("OK.\n");
>  }
>}
>--------------------------------------------------
>
>When you run "bug", it will say:
>GCC says 0xfffffff2 is less than 0x8000000!
>
>However, if it is compiled without -O:
>  gcc -o bug bug.c
>it will say "OK."
>
>This is a 486 running Linux 1.3.8.
Path: meolyon!mwhh!news.Hanse.DE!news.rrz.uni-hamburg.de!zib-berlin.de!fu-berlin.de!news.mathworks.com!news.bluesky.net!news.sprintlink.net!in1.uu.net!cis.ohio-state.edu!meolyon.hanse.DE!amylaar
From: amylaar@meolyon.hanse.DE (Joern Rennecke)
Newsgroups: gnu.gcc.bug
Subject: Bug fix for gcc 2.7.0 bad code generation
Date: 17 Aug 1995 17:34:10 -0400
Organization: GNUs Not Usenet
Lines: 155
Sender: daemon@cis.ohio-state.edu
Approved: bug-gcc@prep.ai.mit.edu
Distribution: gnu
Message-ID: <m0sjAhB-000D1OC@meolyon>

~Newsgroups: gnu.gcc.bug
Path: amylaar
~From: amylaar@meolyon.hanse.de (Joern Rennecke)
~Subject: Bug fix for gcc 2.7.0 bad code generation
Organization: Private site running Linux
Message-ID: <1995Aug17.193337.1772@meolyon.hanse.de>
~Date: Thu, 17 Aug 1995 19:33:37 GMT

The following patch fixes the bug first published as 'unsigned compare'
bug. It is actually not restricted to unsigned comparisons and triggered
in lots of places in the linux kernel source (e.g. a harmless one is
1.2.13 kernel/fork.c line 44).

	Joern Rennecke

diff -cp --recursive gcc-2.7.0/ChangeLog gcc-2.7.0-x/ChangeLog
*** gcc-2.7.0/ChangeLog	Sat Jul  8 01:54:05 1995
--- gcc-2.7.0-x/ChangeLog	Thu Aug 17 21:14:53 1995
***************
*** 1,3 ****
--- 1,23 ----
+ Thu Aug 17 21:02:09 1995 J"orn Rennecke (amylaar@meolyon.hanse.de)
+ 	* i386.c (arithmetic_comparison_operator): New function.
+ 	(print_operand) : take into account that overflow flag is not
+ 	set like after a compare instruction.
+ 	* i386.md (decrement_and_branch_until_zero): use
+ 	arithmetic_comparison_operator to decide if there is an comparison
+ 	that is suitable to be expressed by the condition code from an
+ 	arithmetic operation.
+ 
+ Fri Jul 14 07:34:21 1995  J"orn Rennecke (amylaar@meolyon.hanse.de)
+ 	* c-decl.c(finish_struct): wait with decl_attributes() till
+ 	TYPE_FIELDS (t) is valid.
+ 
+ Thu Jul 13 22:53:04 1995  J"orn Rennecke  (amylaar@meolyon.hanse.de)
+ 	* c-common.c(decl_attributes): bug fix for A_ALIGNED
+ 
+ Sat Jul  8 10:33:59 1995  J"orn Rennecke  (amylaar@meolyon.hanse.de)
+ 	* New optimization option -fomit-default-branch . Most of it
+ 	is in expand_end_case(). Doc in gcc.1
+ 
  Fri Jun 16 06:54:03 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)
  
  	* alpha.c (alpha_builtin_saveregs): Use ptr_mode and conversions
diff -cp --recursive gcc-2.7.0/config/i386/i386.c gcc-2.7.0-x/config/i386/i386.c
*** gcc-2.7.0/config/i386/i386.c	Sat Jul  8 01:54:41 1995
--- gcc-2.7.0-x/config/i386/i386.c	Thu Aug 17 19:42:19 1995
*************** expander_call_insn_operand (op, mode)
*** 1400,1405 ****
--- 1400,1424 ----
      return 1;
    return 0;
  }
+ 
+ /* Return 1 if OP is a comparison operator that can use the condition code
+    generated by an arithmetic operation. */
+ 
+ int
+ arithmetic_comparison_operator (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   enum rtx_code code;
+ 
+   if (mode != VOIDmode && mode != GET_MODE (op))
+     return 0;
+   code = GET_CODE (op);
+   if (GET_RTX_CLASS (code) != '<')
+     return 0;
+ 
+   return (code != GT && code != LE);
+ }
  
  /* Returns 1 if OP contains a symbol reference */
  
*************** print_operand (file, x, code)
*** 2375,2388 ****
  	    {
  	    case NE:  fputs ("jne", file); return;
  	    case EQ:  fputs ("je",  file); return;
! 	    case GE:  fputs ("jge", file); return;
! 	    case GT:  fputs ("jg",  file); return;
! 	    case LE:  fputs ("jle", file); return;
! 	    case LT:  fputs ("jl",  file); return;
! 	    case GEU: fputs ("jae", file); return;
! 	    case GTU: fputs ("ja",  file); return;
! 	    case LEU: fputs ("jbe", file); return;
! 	    case LTU: fputs ("jb",  file); return;
  	    }
  	  abort ();
  
--- 2394,2407 ----
  	    {
  	    case NE:  fputs ("jne", file); return;
  	    case EQ:  fputs ("je",  file); return;
! 	    case GE:  fputs ("jns", file); return;
! 	    case LT:  fputs ("js",  file); return;
! 	    case GEU: fputs ("jmp", file); return;
! 	    case GTU: fputs ("jne",  file); return;
! 	    case LEU: fputs ("je", file); return;
! 	    case LTU: fputs ("#branch never",  file); return;
! 
! 	    /* no matching branches for GT nor LE */
  	    }
  	  abort ();
  
diff -cp --recursive gcc-2.7.0/config/i386/i386.md gcc-2.7.0-x/config/i386/i386.md
*** gcc-2.7.0/config/i386/i386.md	Sat Jul  8 01:54:42 1995
--- gcc-2.7.0-x/config/i386/i386.md	Thu Aug 17 19:55:17 1995
***************
*** 4910,4915 ****
--- 4910,4918 ----
    return AS1 (jmp,%*%0);
  }")
  
+ ;; ??? could transform while(--i > 0) S; to if (--i > 0) do S; while(--i);
+ ;;     if S does not change i
+ 
  (define_expand "decrement_and_branch_until_zero"
    [(parallel [(set (pc)
  		   (if_then_else (ge (plus:SI (match_operand:SI 0 "general_operand" "")
***************
*** 4925,4931 ****
  
  (define_insn ""
    [(set (pc)
! 	(if_then_else (match_operator 0 "comparison_operator"
  				      [(plus:SI (match_operand:SI 1 "general_operand" "+r,m")
  						(match_operand:SI 2 "general_operand" "rmi,ri"))
  				       (const_int 0)])
--- 4928,4934 ----
  
  (define_insn ""
    [(set (pc)
! 	(if_then_else (match_operator 0 "arithmetic_comparison_operator"
  				      [(plus:SI (match_operand:SI 1 "general_operand" "+r,m")
  						(match_operand:SI 2 "general_operand" "rmi,ri"))
  				       (const_int 0)])
***************
*** 4952,4958 ****
  
  (define_insn ""
    [(set (pc)
! 	(if_then_else (match_operator 0 "comparison_operator"
  				      [(minus:SI (match_operand:SI 1 "general_operand" "+r,m")
  						 (match_operand:SI 2 "general_operand" "rmi,ri"))
  				       (const_int 0)])
--- 4955,4961 ----
  
  (define_insn ""
    [(set (pc)
! 	(if_then_else (match_operator 0 "arithmetic_comparison_operator"
  				      [(minus:SI (match_operand:SI 1 "general_operand" "+r,m")
  						 (match_operand:SI 2 "general_operand" "rmi,ri"))
  				       (const_int 0)])

